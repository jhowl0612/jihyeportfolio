<!doctype html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
	<title>코딩 일기장 2020</title>
	<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
	<link rel="icon" href="favicon.ico" type="image/x-icon">
	<link href="https://fonts.googleapis.com/css?family=Noto+Sans+KR" rel="stylesheet">
	<link rel="stylesheet" href="css/style.css"/>
	<script src="js/jquery-1.9.1.min.js"></script>
	<script src="js/script.js"></script>
</head>
<body>
	<div id="wrap">
		<div id="top">
			<h1><a href="index.html">코딩 일기장 2020</a></h1>
			<h2><a href="../diary2019/index.html" target="_blank">일기장 2019 →</a></h2>
		</div>
		<div id="container" class="cf">
			<div id="left">
				<ul>
					<li><a href="#">Vue</a></li>
					<li><a href="#">React</a></li>
					<li><a href="#">spring</a></li>
				</ul>
			</div>
			<div id="right">
				<ul class="article">
					<li class="vue on">
						<div>
							<p>인프런 강의 : 웹 게임을 만들며 배우는 Vue</p>
							<ul>
								<li>
									<a href="vue/vue-webgame/01/like.html" target="_blank">좋아요 버튼 예제 ( el, data, methods, v-on, v-if, v-else )</a>
									<ul>
										<li><strong>v-on</strong> : HTML과 Vue 메소드 연결. HTML에서 이벤트가 일어날 때 뷰에서 실행할 메소드 지정.</li>
										<li><strong>v-if / v-else</strong> : 조건에 따라 가시/비가시화</li>
										<li>Vue와 React의 요점은 "데이터가 바뀔 시 화면은 프레임워크가 알아서 바꾸어 준다" → <strong>양방향 바인딩</strong></li>
										<li>show() 같은 것 필요 없음</li>
										<li>v-on: 은 생략하고 @로 대체 가능. ( v-on:submit → @submit )</li>
									</ul>
								</li>
								<li>
									<a href="vue/vue-webgame/01/gugudan.html" target="_blank">구구단 문제 예제 ( v-model, ref, Math.random(), parseInt() )</a>
									<ul>
										<li><strong>v-model</strong> : HTML의 input과 Vue 데이터 연결. 인풋에서 받은 데이터를 뷰에서 무엇으로 부를지 지정.</li>
										<li>Vue는 싱글페이지가 강점인 프레임워크(싱글페이지 어플리케이션)이므로 form의 새로고침을 막아야 함. 하면 의미 없음.</li>
										<li><strong>ref</strong> : 데이터 조작 없이 화면에 보이는 것을 따로 조작할 때, 태그에 별명을 붙이기 위해 사용</li>
										<li>ref="answer" / this.$refs.answer.focus()</li>
										<li>새로고침을 막기 위해 methods에 e.preventDefault를 작성해야 하지만, 이벤트리스너에 .prevent를 추가하면 생략 가능.<br> ( @submit → @submit.prevent )</li>
									</ul>
								</li>
								<li>
									<a href="vue/vue-webgame/02/wordChain.html" target="_blank">끝말잇기 예제</a>
									<ul>
										<li>구구단 예제의 복습 + 문자열 마지막 글자, 첫 글자 비교</li>
										<li>wordChain(카멜표기법) / WordChain(파스칼표기법) / word-chain(케밥표기법)</li>
									</ul>
								</li>
								<li>
									<a href="vue/vue-webgame/02/wordChain2.html" target="_blank">끝말잇기 예제 x 3 (전역 컴포넌트component, 프롭스props)</a>
									<ul>
										<li><strong>컴포넌트</strong>의 필요성 : 불필요한 반복 방지. 코드를 재사용하여 서로 독립된 끝말잇기 게임을 만듦.<br/>같은 코드를 참조하나, 다른 데이터를 다룬다.</li>
										<li>HTML에서 케밥표기법으로 부르고 Javascript와 Vue에서 카멜표기법으로 부르더라도 알아서 같은 것으로 인식해 줌.<br/>(word-chian = wordChain)</li>
										<li>const app = new Vue ({ }) 방식은 '뷰 인스턴스' / Vue.component( ) 방식은 '뷰 컴포넌트'</li>
										<li>인스턴스에 el: '태그 이름'만 남기고 컴포넌트에 중요 요소를 입력, html 태그도 컴포넌트 template에 입력</li>
										<li>template 바로 아래 태그는 최상위 태그 하나여야 함. 실행 시 template는 사라지고 해당 태그가 최상위 태그가 됨.</li>
										<li>각 컴포넌트에서 다른 데이터를 다루어야 하기 때문에, 컴포넌트의 data는 지정식이 아니라 return이 있는 함수 형태로 입력</li>
										<li>script는 통제할 div보다는 아래에, 컴포넌트는 인스턴스보다 위에 작성</li>
										<li><strong>프롭</strong>은 컴포넌트마다 조금씩 차이점이 필요할 때 사용. (ex. 각 끝말잇기 컴포넌트의 시작단어</li>
										<li>Vue는 복잡할수록, 많은 컴포넌트를 사용할 수록 스크립트의 수와 길이가 많아짐(→ <strong>webpack</strong> 필요성)</li>
									</ul>
								</li>
								<li>
									<a href="vue/vue-webgame/03/numberBaseball.html" target="_blank">숫자 야구 예제 (webpack, nodejs, v-for, map)</a>
									<ul>
										<li><strong>npm init</strong> → <strong>npm install vue</strong> → <strong>npm i webpack webpack-cli -D</strong>
											<ul>
												<li>↑ webpack 개발환경 구축 시 터미널에 입력 / -D는 '개발 환경에서만 사용' 의미</li>
											</ul>
										</li>
										<li>package.json : 사용되는 스크립트들의 버전정보 저장.</li>
										<li>webpack.config.js : 옵션 작성. 배포 시 스크립트를 한 개로 압축.(=웹패킹)
											<ul>
												<li>entry, moduls(rules), plugin, output 4 파트가 필수적.</li>
											</ul>
										</li>
										<li>main.js 는 뷰 인스턴스, numberBaseball.vue 는 뷰 컴포넌트</li>
										<li>vue 파일은 template, script, style 태그로 구성되어 있지만 그 안은 js 문법. (함께 작성할 수 있도록 조치되어 있는 것)</li>
										<li>[webpack.config.js] <strong>const path = require( 'path' )</strong>; / 노드js 에 내장된 path 모듈 부르기.</li>
										<li>[webpack.config.js] <strong>path.join(__dirname, '/test')</strong> / 현재 위치의 절대 경로 + test(하위 폴더 or 파일) / path 모듈의 기능</li>
										<li>[package.json] <strong>"scripts": { "build(임의지정명)" : "webpack" }</strong>
											<ul>
												<li>터미널에서 npm run build 를 입력할 시 웹패킹 시작. 스크립트를 수정할 때마다 run build를 다시 하기.</li>
											</ul>
										</li>
										<li>[webpack.config.js] vue 파일은 100% js문법이 아니기 때문에 뷰 로더를 사용(예외사항)하도록 "rules"에 명시.
											<ul>
												<li>(+ 터미널로 뷰 로더 설치) <strong>npm i vue-loader -D</strong></li>
												<li>(+ 컴파일러 설치) <strong>npm i vue-template-compiler -D</strong> / 컴파일러는 vue와 버전이 같아야 함.</li>
											</ul>
										</li>
										<li>npm i vue@2.7.0 ← 버전 명시하면 해당 버전으로 깔림</li>
										<li><strong>&lt;li v-for="t in tries" :key="t.try"&gt;</strong> : tries는 배열, t는 각 값, v-for는 반복문 / "tries를 돌면서 값을 한 번씩 호출하시오"
											<ul>
												<li><strong>v-bind:key</strong> : v-for로 생성된 다수의 엘리먼트를, key로 각각 다른 이름을 붙여 구별함.</li>
												<li>각 엘리먼트가 구별되면, 화면을 바꿀 때 바꿀 필요 없는 건 건드리지 않을 수 있어 성능이 향상됨.</li>
												<li> 키도 배열 모양새 필요. v-for="t in tries"일 떄, t + abc / t + MAth.random() 등 중복되는 값이 없기만 하면 됨</li>
											</ul>
										</li>
										<li>value.split('').map(v => parseInt(v)) / <strong>map</strong> : '배열의 매 값마다 지정한 동작을 실행하는' 함수</li>
										<li>백틱(숫자 1 왼쪽에 있는``)으로 문자열을 쓰면, 문자열 내에서 ${ }를 사용하여 <strong>변수를 끼워넣을</strong> 수 있다.(js)</li>
										<li>바벨babel은 js에서 지원하지 않는 최신 문법을 쓸 때, ie같은 너무 오래된 브라우저를 지원할 때 씀(아직은 필요x)</li>
										<li>뷰는 에러 메시지가 친절하므로 많이 참고할 것. 구글 검색해도 ㅇㅋ</li>
										<li>컴포넌트 밖의 함수로 빼도 문제없으면 빼기. 다른 컴포넌트에서 사용할 수도 있으니까.(컴포넌트의 필요성과 궤가 같음)</li>
									</ul>
								</li>
								<li>
									<a href="vue/vue-webgame/04/responseCheck.html" target="_blank">반응속도게임 예제 (webpack watch, webpack dev, v-bind, scoped, reduce, computed, template)</a>
									<ul>
										<li>setTimeout - 대표적인 비동기작업. 이 함수로 만드는 웹게임</li>
										<li>package.json에 사용되는 스크립트, 소스코드를 미리 적어두었을 경우, <strong>npm i</strong> 만 입력해도 전부 다운로드</li>
										<li>모듈 폴더가 무거워 깃에 올리기 비효율적임 .gitignore 파일 생성하고 폴더명 적기</li>
										<li>[package.json] "scripts": { "build" : "webpack <strong>--watch</strong>" } 추가할 경우 수정시마다 자동으로 웹팩 재실행</li>
										<li><strong>v-bind</strong> : HTML 속성의 <strong>값</strong>과 data 연결. (ex. "클래스명" 을 뷰 데이터에서 조작할 때)</li>
										<li>v-bind: 는 :로 대체 가능. ( v-bind:class → :class )</li>
										<li><strong>npm i -D webpack-dev-server</strong> / [package.json] scripts에 "dev" : "webpack-dev-server --hot" 추가
											<ul>
												<li>npm run dev 실행시 출력되는 http://localhost:8080/ 에 접속할 경우, 저장시 새로고침하지 않아도 갱신됨</li>
												<li>웹패킹 결과물(dist/app.js)이 파일로 저장되지 않고 메모리에서 실행됨 / ← 이를 위해 config.js 파일에 <strong>publicpath: '/dist'</strong> 명시</li>
											</ul>
										</li>
										<li>&lt;style </style><strong>scoped</strong>&gt; : css가 현 컴포넌트에만 적용되도록. #screen이라는 셀렉터를 다른 컴포넌트에서 따로 사용 가능.</li>
										<li>result.reduce((a, c) => a + c, 0) / <strong>reduce</strong> : 배열 값을 모두 더할 때 주로 씀. 값에 차례대로 같은 동작을 해 하나의 값을 만듦</li>
										<li>{{ ~ || 0 }} / || 는 앞 구문이 False일 때 뒤를 실행하므로, 페이지 첫 로드시 앞 구문이 빈 값일 때 기본값으로 0을 띄울 수 있음</li>
										<li><strong>computed</strong> : 데이터를 계산한 결과를 표시하고 싶을 때, data와 template 사이에서 계산하는 구간.
											<ul>
												<li>↑ template {{ }} 안에서 계산도 가능하나 비권장. 화면의 다른 데이터가 바뀔 때 계산식도 재실행된다.</li>
												<li>↑ computed는 캐싱됨. 계산식 관련 데이터가 바뀌었을 때만 재계산. 계산결과 return하는 함수명을 {{ }}에 적으면 ㅇㅋ</li>
												<li>성능과 직결되므로 가능하다면 최대한 사용★</li>
											</ul>
										</li>
										<li><strong>v-show</strong> : 값이 False일 때 display:none. / v-if는 False일 때 주석처리.
											<ul>
												<li>v-if는 레이아웃을 신경써야 하지만 v-else-if 등을 활용할 수 있어 선호됨</li>
											</ul>	
										</li>
										<li><strong>template</strong> : div → template으로 교체 가능. 실제 웹 페이지에서는 사라지는 태그. 최상위 div는 대체불가</li>	
									</ul>
								</li>
								<li>
									<a href="vue/vue-webgame/05/rockScissorsPaper.html" target="_blank">가위바위보 예제 (:class, :style, 라이프사이클, Object.entries, find)</a>
									<ul>
										<li><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=ko" target="_blank">Vue.js devtools 크롬 확장 프로그램</a>  </li>	
										<li>컴포넌트 이름은 2단어 이상으로(하이픈(-)으로 연결하거나 등) 짓는 게 공식적으로 권장됨. 기존 html 태그와 혼동하지 않도록</li>
										<li>v-bind에서 class와 style(<strong>:class, :style</strong>)만은 값에 객체 형식을 지원함
											<ul>
												<li>:class="{ state: true, hello: false }" :style="{ backgroundImage: '', fontSize: '14px' }" / js이기 때문에 카멜표기법 사용</li>
											</ul>
										</li>
										<li>var는 var a = 111 선언 후 var a = 222 선언 가능(재선언)
											<ul>
												<li>let은 let a = 222 '재선언'은 불가, a = 222 같은 값 변경(재할당)은 가능. / 변수 선언(let b)만 하고 나중에 값 할당 가능</li>
												<li>const는 재선언 재할당 둘 다 불가. a = 222까지 불가능. / 변수 선언 시에 무조건 값 할당.</li>
											</ul>
										</li>
										<li>Vue의 라이프사이클 : created, mounted, updated, destroyed
											<ul>
												<li>created : 요소가 화면에 나오는 것이 결정됨(코드가 다 준비됨) / mounted : 화면에 출력됨(직후) / updated : 데이터가 바뀌어서 화면이 수정됨 / destroyed : 화면에서 사라짐(ex. v-if="false")</li>
												<li>화면 조작은 주로 mounted에서 한다. 화면이 출력되기 전에 하면 적용이 안 되는 경우가 있음.</li>
												<li>= 화면이 시작되자마자 조작하려면 mounted에 적는다</li>
												<li>네 과정에 각각 beforeCreate 등 before 과정이 있음.</li>
												<li>컴포넌트가 사라져도 interval이 반복되어 메모리누수가 발생하므로, beforedestroy에서 clearinterval을 한다. (destroyed도 가능)</li>
											</ul>
										</li>
										<li>단순히 구문 반복을 막기 위해서도 메소드를 쓸 수 있음(setInterval을 메소드로 만들어 구문 반복 회피)</li>
										<li>Object.entries('사전') : 사전의 각 키:값 한 쌍씩, 배열 하나로 만들어 2차원 배열로 뱉음. [ ["키1","값1"], ["키2","값2"] ]</li>
										<li>~ entries('사전').find(function(v){ }) : 바깥 배열을 돌면서, 안의 각 값(안쪽배열 하나씩, v로 호명함) 중 원하는 값 찾기.</li>     
										<li>async / await : js 비동기 처리를 위해 함수 앞 / 객체 앞에 붙이는 구문. 콜백 대신 사용.</li>
									</ul>
								</li>
								<li>
									<a href="vue/vue-webgame/06/lottoGenerator.html" target="_blank">로또 추첨기 예제 (복수 컴포넌트, 반복문, props, watch)</a>
									<ul>
										<li>push를 통해 배열에 공을 1초마다 하나씩 추가, 배열을 돌며 v-for가 공 HTML을 생성, 자식 컴포넌트가 색 지정</li>
										<li>.vue 파일(컴포넌트)을 여러 개 작성. 컴포넌트1의 template에 컴포넌트2의 결과물 엘리먼트를 적으면, 2가 자식 컴포넌트
											<ul>
												<li>자식 컴포넌트 엘리먼트( &lt;lotto-ball&gt; )에 v-for, v-if, <strong>v-bind, props</strong> 등을 연결하는 것이 가능.</li>
												<li>부모자식 연결: 부모 script 안에 import ~ from 자식 파일 부르기, components: {'자식 이름'}</li>
											</ul>
										</li>
										<li>부모 - 자식 컴포넌트 간 props 이동이 중요
											<ul>
												<li>props는 부모가 자식에게 데이터를 내려보낼 때 사용. (ex.로또 번호는 부모에서 만들어지는데, 색 표시는 자식이 함.)</li>
												<li>props로 받은 건 메소드에서 수정 불가능. 사용만 가능. 변경하고 싶다면 애초에 props로 데이터가 아니라 메소드 보내기</li>
												<li><strong>props도 v-bind가 됨.</strong> ← 중요! 이 예제에선 v-for로 배열을 돌며 받은 데이터를 v-bind로 바로 props로 넘김</li>
												<li>props는 자식 컴포넌트에서 자료형을 명시하는 것이 거의 필수로 권장됨.(ex. props: { number: Number })</li>
											</ul>
										</li>
										<li><strong>Array('숫자').fill().map((v, i) =&gt; i + 1)</strong> : 빈 배열 .반복문 먹히도록 fill .각 인덱스값 + 1인 수로 채움 = 1 ~ 45 배열</li>
										<li><strong>splice</strong> : 배열에서 뽑아낸 것을 배열로 뱉음 / <strong>sort((p, c) =&gt; p - c)</strong> : 오름차순 배열 (p - c > 0일 경우 순서 조정)</li>
										<li>새 배열 = [...배열1, ...배열2, 배열아닌데이터] ← 2겹 배열이 아니라 평범한 1겹 배열로 합쳐진다! (ES6 전개연산자)</li>
										<li>아무 것도 안 쓴 data나 methods 구문 남아있으면 오류 뜨니까 지워주기 (자식 컴포넌트)</li>
										<li>setTimeout을 7번 호출하므로, 배열에 담아서 <strong>timeouts.forEach( (t) =&gt; { clearTimeout(t) } )</strong></li>
										<li>watch는 특정 data가 바뀔 때 특정 동작을 수행하는 구간. 되도록 지양됨. 비동기+자동으로 데이터를 바꿔서 파악 어려워짐.
											<ul>
												<li>computed도 데이터가 변하는 걸 감지하는 건 맞지만, 이쪽은 새로운 데이터 하나를 리턴하고 watch는 동작을 수행함.</li>
											</ul>
										</li>
									</ul>
								</li>
								<li>
									<a href="vue/vue-webgame/07/ticTacToe.html" target="_blank">틱택토 예제 (2차원 배열, $root, $parent)</a>
									<ul>
										<li>전체 - 테이블 - tr - td 로 이어지는 복잡한 컴포넌트 구조. 표 전체 재계산을 피하기 위해, 칸마다 다른 컴포넌트로 작성</li>
										<li>구조상 데이터 넘겨주기가 복잡하지만 <strong>this.$root.$data</strong>로 최상위부모, <strong>this.$parent.$data</strong>로 직계부모 데이터 조작 가능</li>
										<li>뷰는 객체를 키로, 배열을 인덱스로 접근해 바꿀 경우(table[0][1]=1), 화면에 반영이 안 됨. 메소드(push 등)로 바꾸면 반영됨
											<ul>
												<li>해결책은 vue.set = $set / <strong>this.$set(table[0], 1(키), 1(값))</strong> 형태. 인덱스를 여러 번 쓸 땐 마지막 인덱스를 키로 적어야 함</li>
											</ul>
										</li>
										<li>if (!cell) {} : cell 값이 없을 때. if (cell)이 'cell 값이 있을 때' 인 것과 반대</li>
										<li>다수 컴포넌트의 이벤트를 중앙 통제하고 싶을 때 사용하는 게 EventBus.
											<ul>
												<li>vue를 임포트하기만 한 EventBus 파일을 만듦, root 파일과 이벤트가 있는 자식 파일에 임포트.</li>
												<li>자식 파일의 메소드 안에서 EventBus.$emit.('이벤트이름', 인자값(필요할 경우))</li>
												<li>루트 파일에서 create () { EventBus.$on('이벤트이름', this.'루트 파일에서의 메소드 이름'); }</li>
											</ul>	
										</li>
										<li>컴포넌트가 많아지면 VueX가 필요해짐. 데이터 중앙 통제 역할. 비동기 조작도 수월해짐.</li>
									</ul>
								</li>
								<li>
									<a href="vue/vue-webgame/07-2/ticTacToe.html" target="_blank">틱택토 (EventBus)</a>
									<ul>
										<li>다수 컴포넌트의 이벤트를 한 곳에서 통제하고 싶을 때 EventBus 사용.</li>
										<li>vue를 임포트하기만 한 EventBus.js 파일을 만듦, root 파일과 이벤트가 있는 자식 파일에 임포트.</li>
										<li>자식 파일의 메소드 안에서 EventBus.$emit.('이벤트이름', 인자값(필요할 경우))</li>
										<li>루트 파일에서 create () { EventBus.$on('이벤트이름', this.'루트 파일에서의 메소드 이름'); }</li>
									</ul>
								</li>
								<li>
									<a href="vue/vue-webgame/07-2/ticTacToe.html" target="_blank">틱택토 (VueX, $store, state, mutations, slot)</a>
									<ul>
										<li>컴포넌트가 많아지면 VueX가 필요해짐. 데이터 중앙 통제 역할. 비동기 조작도 수월해짐.</li>
										<li><strong>store.js</strong> 파일이 데이터 통제. 리액트는 store 파일이 하나여야 하지만 뷰는 여러 개여도 ㅇㅋ</li>
										<li>store.js는 state, getters, mutations, actions 4 파츠로 이루어짐.
											<ul>
												<li>앞의 둘은 data, computed와 유사함.</li>
												<li>mutations는 state를 동기적으로, 하나씩 수정할 때 / actions는 비동기적으로, 여러 개 수정할 때</li>
											</ul>
										</li>
										<li>VueX에는 $set이 없으므로 vue.set 구문 사용 (뒷부분은 같음)</li>
										<li>자식 컴포넌트 computed에서 store를 연결하면 데이터를 루트 컴포넌트에서 부르는 것과 같게 부를 수 있음
											<ul>
												<li>데이터 여러 개라 귀찮으면 mapState 임포트해서 간단하게 쓸 수 있음.</li>
											</ul>
										</li>
										<li>자식 methods의 함수 안에서 this.store.commit(뮤테이션명) 형태로 뮤테이션 실행</li>
										<li>vuex로 했더니 한 칸 누를 때마다 computed의 테이블 전체가 갱신되어서 그냥 합쳐버림 의미없어져서</li>
										<li>부모에는 자식 컴포넌트 엘리먼트 안에 임의 태그를 작성, 자식에는 &lt;slot/&gt; 적어두면, &lt;slot/&gt; 위치에 작성한 태그 붙어 나옴
											<ul>
												<li>렌더링은 자식에서 되지만 내용물 제어는 부모 쪽에서 함. inversion of control이라고 한다.</li>
											</ul>
										</li>
									</ul>
								</li>
								<li>
									<a href="vue/vue-webgame/vue-router-study/router.html" target="_blank">Vue Router (path, 동적 path, 쿼리스트링)</a>
									<ul>
										<li>라우터는 페이지가 이동하는 게 아니라 눈속임이다 라고 함. 실제로는 하나의 페이지이며, 화면과 주소를 바꿈.
											<ul>
												<li>페이지를 데이터로 취급해서 페이지를 바꾸고, 주소도 historyAPI로 바꾼다.</li>
												<li>js에도 주소를 바꾸는 구문이있다. 콘솔에서 histosy.pushState( {}, '', '/hello') 입력하면 사이트명/hello로 주소 바뀜</li>
											</ul>
										</li>
										<li><strong>router-view</strong> : 바뀌는 화면이 들어가는 라우터 HTML 태그 / <strong>router-link</strong> : 라우터 네비게이션 HTML 태그</li>
									</ul>
								</li>
							</ul>
						</div>
					</li>
					<li class="react">
						<div>
							<p>인프런 강의 : 리액트 처음이시라구요?</p>
							<ul>
								<li>
									<a href="#">리액트 기초 예제</a>
									<ul>
										<li>
											<ul>
												<li></li>
											</ul>
										</li>
									</ul>
								</li>
							</ul>
						</div>
					</li>
					<li class="spring">
						<div>
							<p>인프런 강의 : 예제로 배우는 스프링 입문</p>
							<ul>
								<li>
									<a href="#">예제 프로젝트 PetClinic</a>
									<ul>
										<li></li>
									</ul>
								</li>
							</ul>
						</div>
					</li>
				</ul>
			</div>
		</div>
	</div>
</body>
</html>